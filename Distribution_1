import math, random, numpy, multiprocessing

random.seed(0)




# Liste d'utilisation pour chaque learner
C_it = list()
C_jt = list()

# Construction d'une classe de learner : avec les attributs d'intérêt. Note : il est possible d'ajouter des arguments
# comme le nombre de bras (pour l'instant faisons simple).

# Attention à la façon dont on va traiter les choses par la suite. Il faut que le process reste vivant tout au long
# des calculs (et non pas qu'on en créé pour chaque date).

class Learner(multiprocessing.Process):

    def __init__(self, id, Fi, task_queue, result_queue, count_j):
        multiprocessing.Process.__init__(self)
        self.task_queue = task_queue
        self.id = id
        self.Fi = Fi
        self.others = list(i for i in range(M)).remove(self.id)
        self.Eps_i_jpt = numpy.zeros((nb_m, M-1))
        self.count_i_jpt = { s:numpy.zeros(nb_m) for s in self.others}
        self.Eps_i_fpt = numpy.zeros((nb_m, Fi))
        self.count_i_fpt = numpy.zeros((nb_m, Fi))
        self.count_i = numpy.zeros(nb_m)
        self.N_itr_jpt = { s:numpy.zeros(nb_m) for s in self.others}
        self.result_queue = result_queue
        self.count_j = count_j

    # Tache à accomplir : à chaque fois récupérer une tâche dans la queue et effectuer le travail. Si la tâche est
    # None alors cesser de travailler (sortie du loop).

    def CLUPmax_i(self,x_it):
        train = 0
        m_T = len(x_it)
        # Partition en hypercube régulier // recherche de l'index de l'ensemble contenant le contexte
        # Les p.it sont dans (0,m.T-1)
        p = sum((int(x_it[i]*m_T))*m_T**i for i in range (0,m_T))
        # N_ifpt est le vecteur du nombre d'utilisations des bras f du learner i pour l'espace p
        F_ue_ipt = [i for i in range (0,len(self.count_i_fpt[p,])) if self.count_i_fpt[p,i] <= D_1(t) ]
        if len(F_ue_ipt)>0:
            a_i = random.choice(F_ue_ipt)
            choix = "arm"
        else:
            M_ct_ipt = [i for i in self.others if self.N_itr_jpt[i][p] <= D_2(t) ]
            for j in M_ct_ipt:
                # Récupère les informations des autres //
                # PENSER A UPDATER LE COUNT_J PLUS TARD DANS LE CODE
                self.N_itr_jpt[j][p] = count_j['%s %s' % (p, j)] - self.count_i_jpt[j][p]
            M_ut_ipt = [i for i in self.others if self.N_itr_jpt[i][p] <= D_2(t) ]
            M_ue_ipt = [i for i in self.others if self.count_i_jpt[i][p] <= D_3(t) ]
            if len(M_ut_ipt)>0:
                a_i = random.choice(M_ut_ipt)
                choix = "learner"
                train = 1
            elif len(M_ue_ipt)>0:
                a_i = random.choice(M_ue_ipt)
                choix = "learner"
            else:
                # Pour p, pour chaque choix k, reward moyen sur toute la période t
                r_est_ikpt = numpy.append(self.Eps_i_fpt[p, ], self.Eps_i_jpt.values[j][p])/numpy.append(self.count_i_fpt[p, ],
                                    self.count_i_jpt[p, ], for j in self.others)
                rd_est_ikpt = r_est_ikpt # - d_i_k()  # A modifier avec la fonction de cout : pour l'instant en attente
                # Finir : choisir a_i parmi les argmax de r_est_ikpt - d_i_k
                a_i = random.choice(numpy.where(rd_est_ikpt == rd_est_ikpt.max())[0])
                if a_i < Fi:
                    choix = "arm"
                else:
                    choix = "learner"
                    a_i = a_i - Fi
        return {'a_i': a_i , 'choix': choix, 'train' : train, 'p':p}

    def aux(self):
         count_j['%s %s' % (self.id, 1)] = self.id

    def run(self):
        proc_name = self.id
        while True:
            next_task = self.task_queue.get()
            if next_task is None:
                # Poison pill means shutdown
                print("Reward de %s en activant un de ses bras :" % self.id)
                print(self.Eps_i_fpt)
                print("Reward de %s après avoir été sollicité par un autre learner" % self.id)
                print(self.Eps_i_jpt)
                self.task_queue.task_done()
                break
            answer = next_task
            self.aux()
            self.task_queue.task_done()
            self.result_queue.put('%s: %s' % (proc_name, answer))
        return




# D'après ces fonctions de contrôle (p.6),
# on détermine successivement s'il faut entrer en phase :
  # d'exploration de ses bras persos
  # ou d'entraînement
  # ou de jeu

z = 0.5

Fmax = 2

def D_1(t):
    return math.log(t)*t**z

def D_2(t):
    return Fmax*math.log(t)*t**z

def D_3(t):
    return Fmax*math.log(t)*t**z


# Fonction de coût (ici uniforme quelque soit le choix)
def d_i_k():
    return 1

# Reward (ici très simple, elle incorpore même la réponse directement et le coût)

# Ici les machines sont de manière déterministe spécialisées en un ensemble précis (0,1) et (2,3) et leur bras dans un
# sous ensemble de ces mêmes ensembles.

def reward(p,id,choix): # p = espace / id = identifiant du learner (1 ou 2) / choix = choix de l'arm
    if id == 0:
        if p == choix:
            return 1
        else:
            return -1
    else:
        if p == choix+2:
            return 1
        else:
            return -1




if __name__ == '__main__':

    # Nombre de learner, temps total, nombre d'hypercubes
    M = 2
    T = 100
    m_T = 2
    D = 2
    nb_m = m_T**D

    # Création d'un élément partagé par tous que l'on va pouvoir updater
    mgr = multiprocessing.Manager()
    count_j = mgr.dict()

    # Construction d'une Queue
    tasks = multiprocessing.JoinableQueue()
    results = multiprocessing.Queue()


    # Construction des informations
    x_it = numpy.zeros((T, D))
    for t in range(0,T):
        x_it[t, ] = numpy.random.uniform(low=0.0, high=1.0, size=2)


    # Information sur les rewards
    position = numpy.zeros(T)
    for t in range(0,T):
        position[t] = sum((int(x_it[t,i]*m_T))*m_T**i for i in range(0, m_T))


    # Construction des learners
    learners = [Learner(i, 2, tasks, results, count_j) for i in range(M)]


    # Début d'activité
    for l in learners:
        l.start()

    # Ajout des informations dans la Queue
    for t in range(T):
        tasks.put(x_it[t, ])

    # Poison pill pour chaque learner
    for i in range(M):
        tasks.put(None)

    # Attente que chacun a fini (utile pour printer les résultats à la fin)
    tasks.join()

    # Start printing results
    while T:
        result = results.get()
        print('Result:', result)
        T -= 1

    print(count_j)
